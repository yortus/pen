// ===============================================================================
// |                                  Imports                                    |
// ===============================================================================
(ascii, f64) = import 'std'
(unicode) = import 'experiments'


// ===============================================================================
// |                                  Exports                                    |
// ===============================================================================
start = WS   Value   WS


// ===============================================================================
// |                               Implementation                                |
// ===============================================================================

// ---------- Top-Level JSON Values ----------
Value =
    |   False
    |   Null
    |   True
    |   Object
    |   Array
    |   Number
    |   String

// ---------- Primitive values ----------
False   = #"false"   false
Null    = #"null"   null
True    = #"true"   true

// ---------- Objects ----------
Object      = LBRACE   (Properties   |   {})   RBRACE
Properties  = {...Property, ...COMMA Properties}   |   Property
Property    = {[String]: COLON Value}

// ---------- Arrays ----------
Array       = LBRACKET   (Elements   |   [])   RBRACKET
Elements    = [Value, ...COMMA Elements]   |   [Value]      // NB: tail-recursive form - impl efficient handling

// ---------- Numbers ----------
Number = f64

// ---------- Strings ----------
String = DOUBLE_QUOTE   CHAR*   DOUBLE_QUOTE
// TODO: how is string of escape sequence chars (in SPAN) mapped to/from the single char it represents? (in NODE)
//       - something akin to `i32` which parses a number from the input span, call it `char`. Understands common escape sequences
// TODO: should support wider charset than ascii - this is not full JSON
CHAR =
    |   !"\\"   !"\""    ascii(min=0x20 max=0x7f)           // any ascii char except '\', '"', or control char
    |   #"\\\""   '"'                                       // quotation mark
    |   #"\\\\"   '\\'                                      // reverse solidus

    |   #"\\/"   '/'                                        // solidus
    |   #"\\b"   '\b'                                       // backspace
    |   #"\\f"   '\f'                                       // formfeed
    |   #"\\n"   '\n'                                       // newline
    |   #"\\r"  '\r'                                        // carriage return

    |   #"\\t"   '\t'                                       // horizontal tab
    |   #"\\u"   unicode(base=16 minDigits=4 maxDigits=4)   // unicode escape sequence

// ---------- Literal characters ----------

LBRACE          = WS   #"{"   WS
RBRACE          = WS   #"}"   WS
LBRACKET        = WS   #"["   WS

RBRACKET        = WS   #"]"   WS
COLON           = WS   #":"   WS
COMMA           = WS   #","   WS
DOUBLE_QUOTE    = #"\""
WS              = #(" " | "\t" | "\n" | "\r")*




/* syntax ideas...
CHAR =
    |   ifnot   ("\x00-\x1f" | "\"" | "\\")   then   anyChar        // any char except control char, " or \
    |   ...

WS              = repeat (` ` | `\t` | `\n` | `\r`)
WS              = repeat (` ` | `\t` | `\n` | `\r`) for 0..
WS              = for 0.. repeat (` ` | `\t` | `\n` | `\r`)
WS              = repeat (` ` | `\t` | `\n` | `\r`) 0.. times
WS              = repeat 0.. times (` ` | `\t` | `\n` | `\r`)
*/
