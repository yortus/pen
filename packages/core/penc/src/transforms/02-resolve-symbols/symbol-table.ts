import type {V} from '../../representations';


// TODO: jsdoc...
export interface Scope {
    insert(name: string, value: V.Expression<200>): Symbol;
    lookup(name: string): Symbol;
    createNestedScope(): Scope;
    surroundingScope: Scope;
    symbols: Record<string, Symbol | undefined>;
}


// TODO: jsdoc...
export interface Symbol {
    readonly uniqueName: string; // TODO: doc... can be used as an identifier; unique across program
    readonly localName?: string;
    readonly value: V.Expression<200>;

    // TODO: temp testing...
    readonly scope: Scope;
}


// TODO: jsdoc...
export interface SymbolTableOptions {
    onInsert?: (symbol: Symbol) => void;
}


// TODO: jsdoc...
export function createSymbolTable(options?: SymbolTableOptions) {
    const onInsert = options?.onInsert ?? (() => {});
    const RESERVED_UNIQUE_NAMES = ['start'];
    const existingUniqueNames = new Set<string>(RESERVED_UNIQUE_NAMES);
    const rootScope = createNestedScope(undefined);
    return {rootScope};

    // TODO: temp testing...
    function createNestedScope(surroundingScope?: Scope): Scope {
        const symbols: Record<string, Symbol | undefined> = Object.create(surroundingScope?.symbols ?? null);
        const scope: Scope = {
            insert(name, value) {
                if (Object.keys(symbols).includes(name)) {
                    // TODO: improve diagnostic message eg line+col
                    throw new Error(`'${name}' is already defined`);
                }
                const uniqueName = createUniqueName(name);
                const symbol: Symbol = {uniqueName, localName: name, value, scope};
                symbols[name] = symbol;
                //allSymbols[uniqueName] = symbol;
                onInsert(symbol);
                return symbol;
            },

            lookup(name) {
                const symbol = symbols[name];
                if (symbol) return symbol;
                // TODO: improve diagnostic message eg line+col
                throw new Error(`'${name}' is not defined`);
            },

            createNestedScope() {
                return createNestedScope(scope);
            },

            get surroundingScope() {
                if (surroundingScope) return surroundingScope;
                throw new Error(`Cannot get surrounding scope of root scope`);
            },

            symbols,
        };
        return scope;
    }

    // TODO: doc... helper
    function createUniqueName(name: string): string {
        // Ensure no duplicate or reserved uniqueNames are generated by adding a numeric suffix where necessary.
        let result = name;
        let counter = 1;
        while (existingUniqueNames.has(result)) result = `${name}_${++counter}`;
        existingUniqueNames.add(result);
        return result;
    }
}
