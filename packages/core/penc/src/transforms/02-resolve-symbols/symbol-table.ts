import type {Expression} from '../../ast-nodes';
import {assert} from '../../utils';


// TODO: jsdoc...
export type Scope = Record<string, Symbol | undefined>;


// TODO: jsdoc...
export interface Symbol {
    readonly globalName: string; // TODO: doc... can be used as an identifier; unique across program
    readonly localName?: string;
    readonly value: Expression;
}


// TODO: jsdoc...
export function createSymbolTable() {
    const allSymbols = {} as Record<string, Symbol>;
    const RESERVED_GLOBAL_NAMES = ['start'];
    const existingGlobalNames = new Set<string>(RESERVED_GLOBAL_NAMES);
    const scopesByGlobalName = new Map<string, Scope>();

    // Define a root scope.
    const rootScope: Scope = Object.create(null);

    return {
        // TODO: jsdoc...
        allSymbols,

        // TODO: jsdoc...
        createScope(surroundingScope?: Scope): Scope {
            surroundingScope ??= rootScope;
            const scope = Object.create(surroundingScope);
            return scope;
        },

        // TODO: jsdoc...
        // Helper function to add a definition for `name` into the given module's scope.
        define(scope: Scope, name: string, value: Expression): Symbol {
            if (Object.keys(scope).includes(name)) {
                throw new Error(`'${name}' is already defined`); // TODO: improve diagnostic message eg line+col
            }
            const globalName = createGlobalName(name);
            const symbol: Symbol = {globalName, localName: name, value};
            allSymbols[globalName] = symbol;
            scope[name] = symbol;
            scopesByGlobalName.set(globalName, scope);
            return symbol;
        },

        // TODO: jsdoc...
        lookup(scope: Scope, name: string): Symbol {
            const symbol = scope[name];
            if (!symbol) {
                throw new Error(`'${name}' is not defined`); // TODO: improve diagnostic message eg line+col
            }
            return symbol;
        },

        // TODO: jsdoc...
        getScopeFor(symbol: Symbol): Scope {
            const scope = scopesByGlobalName.get(symbol.globalName);
            assert(scope);
            return scope;
        },

        // TODO: jsdoc...
        getSurroundingScope(scope: Scope): Scope | undefined {
            const proto = Object.getPrototypeOf(scope);
            return proto ?? undefined;
        }
    };

    // TODO: doc... helper
    function createGlobalName(name: string): string {
        // Ensure no duplicate or reserved globalNames are generated by adding a numeric suffix where necessary.
        let result = name;
        let counter = 1;
        while (existingGlobalNames.has(result)) result = `${name}${++counter}`;
        existingGlobalNames.add(result);
        return result;
    }
}
