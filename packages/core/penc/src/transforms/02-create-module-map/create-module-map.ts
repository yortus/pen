import {Binding, Identifier, mapNode, Module} from '../../abstract-syntax-trees';
import {SourceFileMap, ModuleMap,} from '../../representations';
import {resolveModuleSpecifier} from '../../utils';


// TODO: wip...
// - replace each ModuleExpression and ImportExpression with a synthesized Identifier to a module in root scope
// TODO: assert moduleMapKibefore returning
export function createModuleMap({sourceFilesByPath, startPath}: SourceFileMap): ModuleMap {

    // TODO: temp testing...
    const genModuleId = createModuleIdGenerator();

    // TODO: temp testing... generate the moduleIds for each file in the program
    const moduleIdsBySourceFilePath: Record<string, string> = {};
    for (let path of Object.keys(sourceFilesByPath)) {
        moduleIdsBySourceFilePath[path] = genModuleId(path);
    }

    const modulesById: Record<string, Module> = {};
    for (let file of Object.values(sourceFilesByPath)) {

        // Add a module to the module map for this file.
        let module: Module = {
            kind: 'Module',
            moduleId: moduleIdsBySourceFilePath[file.path],
            bindings: file.bindings,
        };
        modulesById[module.moduleId] = module;

        // Hoist any inline module expressions out of the AST and into the module map.
        // In this process, each ModuleExpression node is replaced with an equivalent Identifier node.
        let parentModuleIds = [module.moduleId];
        let {bindings} = mapNode(module, rec => ({
            ModuleExpression: (modExpr): Identifier => {
                let moduleId = genModuleId(file.path, 'modexpr');
                let parentModuleId = parentModuleIds[parentModuleIds.length - 1];
                let bindings: Binding[] = [];
                let nestedModule: Module = {kind: 'Module', moduleId, parentModuleId, bindings};
                modulesById[nestedModule.moduleId] = nestedModule;

                // TODO: recurse...
                parentModuleIds.push(nestedModule.moduleId);
                for (let binding of modExpr.bindings) bindings.push(rec(binding));
                parentModuleIds.pop();

                return {
                    kind: 'Identifier',
                    name: moduleId,
                };
            },

            // TODO: ImportExpression...
            ImportExpression: ({moduleSpecifier}): Identifier => {
                const path = resolveModuleSpecifier(moduleSpecifier, file.path);
                return {
                    kind: 'Identifier',
                    name: moduleIdsBySourceFilePath[path],
                };
            },

        }));

        // TODO: what a mess... fix
        Object.assign(module, {bindings});
    }

    // TODO: in debug mode, ensure only allowed node kinds are present in the representation
    // traverseNode(null!, n => assert(moduleMapKinds.matches(n)));

    return {
        modulesById,
        startModuleId: moduleIdsBySourceFilePath[startPath],
    };
}


// TODO: temp testing...
function createModuleIdGenerator() {
    const moduleIds: string[] = [];
    return function generateModuleId(modulePath = '', suffix?: string) {
        let name = modulePath
            .split(/\/+|\\+/) // split on segment delimiters / and \
            .map(s => s.substring(0, s.indexOf('.')) || s) // remove extensions
            .reverse() // reverse the order of the segments
            .concat('module') // add a fallback name to guarantee the result is not undefined
            .filter(seg => seg && seg !== 'index') // remove empty and 'index' segments
            .shift()! // take the first segment
            .replace(/^[0-9]+/g, '') // remove leading digits, if any
            .replace(/[^a-zA-Z0-9ùïä]/g, '_'); // replace all non-alphanumeric chars with '_'
    
        // Prefix moduleId with '@' to ensure it cannot clash with program identifiers.
        // Also add the suffix if one was supplied.
        name = `@${name}`;
        if (suffix) name = `${name}_${suffix}`;

        // Ensure no duplicate moduleIds are generated by adding a numeric suffix where necessary.
        let result = name;
        let counter = 1;
        while (moduleIds.includes(result)) result = `${name}${++counter}`;
        moduleIds.push(result);
        return result;
    }
}
