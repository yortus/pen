import * as fs from 'fs';
import {Binding, File, Identifier, mapNode, Module} from '../../abstract-syntax-trees';
import type {FileMap, SourceFileGraph, ModuleMap} from '../../representations';
import {isExtension} from '../../utils';
import {parse as parseExtFile} from './ext-file-grammar';
import {parse as parsePenFile} from './pen-file-grammar';


// TODO: jsdoc...
export function createFileMap(sourceFileGraph: SourceFileGraph): FileMap {
    const filesByPath: Record<string, File> = {};
    for (const sourceFile of sourceFileGraph.sourceFiles.values()) {
        const sourceText = fs.readFileSync(sourceFile.path, 'utf8');
        const parse = isExtension(sourceFile.path) ? parseExtFile : parsePenFile;
        const file = parse(sourceText, {sourceFile});
        filesByPath[file.path] = file;
    }
    return {
        filesByPath,
        startPath: sourceFileGraph.mainPath,
    };
}




// TODO: wip...
// - replace each ModuleExpression and ImportExpression with a synthesized Identifier to a module in root scope
export function createModuleMap(sourceFileGraph: SourceFileGraph): ModuleMap {

    // TODO: temp testing...
    const fileMap = createFileMap(sourceFileGraph);

    // TODO: temp testing...
    const genModuleId = createModuleIdGenerator();

    // TODO: temp testing... generate the moduleIds for each file in the program
    const moduleIdsByFilePath: Record<string, string> = {};
    for (let {path} of Object.values(fileMap.filesByPath)) {
        moduleIdsByFilePath[path] = genModuleId(path);
    }

    const modulesById: Record<string, Module> = {};
    for (let file of Object.values(fileMap.filesByPath)) {

        // Add a module to the module map for this file.
        let module: Module = {
            kind: 'Module',
            moduleId: moduleIdsByFilePath[file.path],
            bindings: file.bindings,
        };
        modulesById[module.moduleId] = module;

        // Hoist any inline module expressions out of the AST and into the module map.
        // In this process, each ModuleExpression node is replaced with an equivalent Identifier node.
        let parentModuleIds = [module.moduleId];
        let {bindings} = mapNode(module, rec => ({
            ModuleExpression: (modExpr): Identifier => {
                let moduleId = genModuleId(file.path, 'modexpr');
                let parentModuleId = parentModuleIds[parentModuleIds.length - 1];
                let bindings: Binding[] = [];
                let nestedModule: Module = {kind: 'Module', moduleId, parentModuleId, bindings};
                modulesById[nestedModule.moduleId] = nestedModule;

                // TODO: recurse...
                parentModuleIds.push(nestedModule.moduleId);
                for (let binding of modExpr.bindings) bindings.push(rec(binding));
                parentModuleIds.pop();

                return {
                    kind: 'Identifier',
                    name: moduleId,
                };
            },

            // TODO: ImportExpression...
            ImportExpression: (impExpr): Identifier => {
                return {
                    kind: 'Identifier',
                    name: moduleIdsByFilePath[impExpr.path],
                };
            },

        }));

        // TODO: what a mess... fix
        Object.assign(module, {bindings});
    }
    return {
        modulesById,
        startModuleId: moduleIdsByFilePath[sourceFileGraph.mainPath],
    };


    // TODO: temp testing...
    function createModuleIdGenerator() {
        const moduleIds: string[] = [];
        return function generateModuleId(modulePath = '', suffix?: string) {
            let name = modulePath
                .split(/\/+|\\+/) // split on segment delimiters / and \
                .map(s => s.substring(0, s.indexOf('.')) || s) // remove extensions
                .reverse() // reverse the order of the segments
                .concat('module') // add a fallback name to guarantee the result is not undefined
                .filter(seg => seg && seg !== 'index') // remove empty and 'index' segments
                .shift()! // take the first segment
                .replace(/^[0-9]+/g, '') // remove leading digits, if any
                .replace(/[^a-zA-Z0-9ùïä]/g, '_'); // replace all non-alphanumeric chars with '_'
        
            // Prefix moduleId with '@' to ensure it cannot clash with program identifiers.
            // Also add the suffix if one was supplied.
            name = `@${name}`;
            if (suffix) name = `${name}_${suffix}`;

            // Ensure no duplicate moduleIds are generated by adding a numeric suffix where necessary.
            let result = name;
            let counter = 1;
            while (moduleIds.includes(result)) result = `${name}${++counter}`;
            moduleIds.push(result);
            return result;
        }
    }
}
