import {Binding, Expression, Identifier, mapNode, Module, traverseNode} from '../../abstract-syntax-trees';
import {SourceFileMap, ModuleMap, moduleMapKinds} from '../../representations';
import {assert, mapObj, resolveModuleSpecifier} from '../../utils';


// TODO: jsdoc...
// - takes a collection of source files
// - converts all ImportExpressions to Identifiers, so there are no ImportExpression nodes in the output
// - converts all bindings to the Record (not array) form, so there are no Binding or ModulePattern nodes in the output
// - makes a single expression for the program synthesizing a root module and member expressions
export function createModuleMap({sourceFilesByPath, startPath}: SourceFileMap): ModuleMap {

    // TODO: temp testing...
    const genModuleId = createModuleIdGenerator();
    const moduleIdsBySourceFilePath: Record<string, string> = {};
    for (let path of Object.keys(sourceFilesByPath)) {
        moduleIdsBySourceFilePath[path] = genModuleId(path);
    }

    // TODO: temp testing...
    const rootModuleBindings = Object.entries(sourceFilesByPath).reduce(
        (rootModuleBindings, [sourceFilePath, {bindings}]) => {
            const moduleId = moduleIdsBySourceFilePath[sourceFilePath];
            const bindingsArray = bindings.map(binding => mapNode(binding, rec => ({
                BindingList: ({bindings: bindingsArray}): Module => {
                    let bindings = convertBindings(bindingsArray);
                    bindings = mapObj(bindings, rec);
                    return {kind: 'Module', bindings};
                },
                ImportExpression: ({moduleSpecifier}): Identifier => {
                    const path = resolveModuleSpecifier(moduleSpecifier, sourceFilePath);
                    return {kind: 'Identifier', name: moduleIdsBySourceFilePath[path]};
                },
            })));
            rootModuleBindings[moduleId] = {kind: 'Module', bindings: convertBindings(bindingsArray)};
            return rootModuleBindings;
        },
        {} as Record<string, Expression>
    );

    // TODO: temp testing...
    const rootModule: Module = {kind: 'Module', bindings: rootModuleBindings};
    const startName = 'ùïätart'; // TODO: ensure no name clashes with other program identifiers
    rootModuleBindings[startName] = {
        kind: 'MemberExpression',
        module: {kind: 'Identifier', name: moduleIdsBySourceFilePath[startPath]},
        member: {kind: 'Identifier', name: 'start'},
    };

    // TODO: in debug mode, ensure only allowed node kinds are present in the representation
    traverseNode(rootModule, n => assert(moduleMapKinds.matches(n)));

    return {rootModule, startName};
}


// TODO: temp testing...
function createModuleIdGenerator() {
    const moduleIds: string[] = [];
    return function generateModuleId(modulePath = '') {
        let name = modulePath
            .split(/\/+|\\+/) // split on segment delimiters / and \
            .map(s => s.substring(0, s.indexOf('.')) || s) // remove extensions
            .reverse() // reverse the order of the segments
            .concat('module') // add a fallback name to guarantee the result is not undefined
            .filter(seg => seg && seg !== 'index') // remove empty and 'index' segments
            .shift()! // take the first segment
            .replace(/^[0-9]+/g, '') // remove leading digits, if any
            .replace(/[^a-zA-Z0-9ùïä]/g, '_'); // replace all non-alphanumeric chars with '_'
    
        // Prefix moduleId with '‚±Æ_' to ensure it cannot clash with program identifiers.
        // TODO: but that could be a valid id in future... ensure *can't* clash
        // Also add the suffix if one was supplied.
        name = `‚±Æ_${name}`;

        // Ensure no duplicate moduleIds are generated by adding a numeric suffix where necessary.
        let result = name;
        let counter = 1;
        while (moduleIds.includes(result)) result = `${name}${++counter}`;
        moduleIds.push(result);
        return result;
    }
}


// TODO: temp testing...
function convertBindings(bindingsArray: readonly Binding[]): {readonly [name: string]: Expression} {
    const result = {} as {[name: string]: Expression};
    for (let {left, right} of bindingsArray) {
        if (left.kind === 'Identifier') {
            if (result.hasOwnProperty(left.name)) {
                // TODO: improve diagnostic message eg line+col
                new Error(`'${left.name}' is already defined`);
            }
            result[left.name] = right;
        }
        else /* left.kind === 'ModulePattern */ {
            for (let {name, alias} of left.names) {
                if (result.hasOwnProperty(alias || name)) {
                    // TODO: improve diagnostic message eg line+col
                    new Error(`'${alias || name}' is already defined`);
                }
                result[alias || name] = {
                    kind: 'MemberExpression',
                    module: right,
                    member: {kind: 'Identifier', name},
                };
            }
        }
    }
    return result;
}
