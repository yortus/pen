import {Binding, Expression, Identifier, mapNode, Module} from '../../abstract-syntax-trees';
import {SourceFileMap, ModuleMap} from '../../representations';
import {mapObj, resolveModuleSpecifier} from '../../utils';


// TODO: jsdoc...
// - takes a collection of source files
// - converts all ModuleExpressions and ImportExpressions to Identifiers
// - outputs a collection of modules
export function createModuleMap({sourceFilesByPath, startPath}: SourceFileMap): ModuleMap {

    // TODO: temp testing...
    const genModuleId = createModuleIdGenerator();

    // TODO: temp testing... generate the moduleIds for each file in the program
    const moduleIdsBySourceFilePath: Record<string, string> = {};
    for (let path of Object.keys(sourceFilesByPath)) {
        moduleIdsBySourceFilePath[path] = genModuleId(path);
    }

    const modulesById: Record<string, Module> = {};
    const parentModuleIdsByModuleId: Record<string, string> = {};
    for (let file of Object.values(sourceFilesByPath)) {

        // Add a module to the module map for this file.
        const moduleId = moduleIdsBySourceFilePath[file.path];
        const module: Module = {
            kind: 'Module',
            bindings: convertBindings(file.bindings),
        };
        modulesById[moduleId] = module;

        // Hoist any inline module expressions out of the AST and into the module map.
        // In this process, each ModuleExpression node is replaced with an equivalent Identifier node.
        let parentModuleIds = [moduleId];
        let {bindings} = mapNode(module, rec => ({
            ModuleExpression: (modExpr): Identifier => {
                let exprModuleId = genModuleId(file.path, 'modexpr');
                let parentModuleId = parentModuleIds[parentModuleIds.length - 1];
                parentModuleIdsByModuleId[exprModuleId] = parentModuleId;
                let nestedModule: Module = {kind: 'Module', bindings: {}};
                modulesById[exprModuleId] = nestedModule;

                // TODO: recurse...
                parentModuleIds.push(exprModuleId);
                let bindings = Array.isArray(modExpr.bindings) ? convertBindings(modExpr.bindings) : modExpr.bindings;
                bindings = mapObj(bindings, rec);
                Object.assign(nestedModule, {bindings}); // TODO: nasty rewrite of readonly, fix
                parentModuleIds.pop();

                return {
                    kind: 'Identifier',
                    name: exprModuleId,
                };
            },

            // TODO: ImportExpression...
            ImportExpression: ({moduleSpecifier}): Identifier => {
                const path = resolveModuleSpecifier(moduleSpecifier, file.path);
                return {
                    kind: 'Identifier',
                    name: moduleIdsBySourceFilePath[path],
                };
            },

        }));

        // TODO: what a mess... fix
        Object.assign(module, {bindings});
    }

    // TODO: in debug mode, ensure only allowed node kinds are present in the representation
    // traverseNode(null!, n => assert(moduleMapKinds.matches(n)));

    return {
        modulesById,
        parentModuleIdsByModuleId,
        startModuleId: moduleIdsBySourceFilePath[startPath],
    };
}


// TODO: temp testing...
function createModuleIdGenerator() {
    const moduleIds: string[] = [];
    return function generateModuleId(modulePath = '', suffix?: string) {
        let name = modulePath
            .split(/\/+|\\+/) // split on segment delimiters / and \
            .map(s => s.substring(0, s.indexOf('.')) || s) // remove extensions
            .reverse() // reverse the order of the segments
            .concat('module') // add a fallback name to guarantee the result is not undefined
            .filter(seg => seg && seg !== 'index') // remove empty and 'index' segments
            .shift()! // take the first segment
            .replace(/^[0-9]+/g, '') // remove leading digits, if any
            .replace(/[^a-zA-Z0-9ùïä]/g, '_'); // replace all non-alphanumeric chars with '_'
    
        // Prefix moduleId with '‚±Æ_' to ensure it cannot clash with program identifiers.
        // TODO: but that could be a valid id in future... ensure *can't* clash
        // Also add the suffix if one was supplied.
        name = `‚±Æ_${name}`;
        if (suffix) name = `${name}_${suffix}`;

        // Ensure no duplicate moduleIds are generated by adding a numeric suffix where necessary.
        let result = name;
        let counter = 1;
        while (moduleIds.includes(result)) result = `${name}${++counter}`;
        moduleIds.push(result);
        return result;
    }
}


// TODO: temp testing...
function convertBindings(bindings: readonly Binding[]): {readonly [name: string]: Expression} {
    const result = {} as {[name: string]: Expression};
    for (let {left, right} of bindings) {
        if (left.kind === 'Identifier') {
            if (result.hasOwnProperty(left.name)) {
                // TODO: improve diagnostic message eg line+col
                new Error(`'${left.name}' is already defined`);
            }
            result[left.name] = right;
        }
        else /* left.kind === 'ModulePattern */ {
            for (let {name, alias} of left.names) {
                if (result.hasOwnProperty(alias || name)) {
                    // TODO: improve diagnostic message eg line+col
                    new Error(`'${alias || name}' is already defined`);
                }
                result[alias || name] = {
                    kind: 'MemberExpression',
                    module: right,
                    member: {kind: 'Identifier', name},
                };
            }
        }
    }
    return result;
}
