// TODO: jsdoc...
export function createModuleNameGenerator() {
    const RESERVED_NAMES = ['start'];
    const existingModuleNames: string[] = [...RESERVED_NAMES];
    return function generateModuleName(modulePath: string) {
        let name = modulePath
            .split(/\/+|\\+/) // split on segment delimiters / and \
            .map(s => s.substring(0, s.indexOf('.')) || s) // remove extensions
            .reverse() // reverse the order of the segments
            .concat('module') // add a fallback name to guarantee the result is not undefined
            .filter(seg => seg && seg !== 'index') // remove empty and 'index' segments
            .shift()! // take the first segment
            .replace(/^[0-9]+/g, '') // remove leading digits, if any
            .replace(/[^a-zA-Z0-9ùïä]/g, '_'); // replace all non-alphanumeric chars with '_'
    
        // Prefix module name with '‚±Æ_' to ensure it cannot clash with program identifiers.
        // TODO: but that could be a valid id in future... ensure *can't* clash
        name = `‚±Æ_${name}`;

        // Ensure no duplicate or reserved module names are generated by adding a numeric suffix where necessary.
        let result = name;
        let counter = 1;
        while (existingModuleNames.includes(result)) result = `${name}${++counter}`;
        existingModuleNames.push(result);
        return result;
    }
}
