Todo:
    add mocha/chai unit tests to core pen module:
      [ ] add expression grammar as a fixture
      [ ] tests that parse various math expressions and expect a specific ast
      [ ] tests that unparse various math expr asts and expect specific text
      [ ] parse/unparse round-trips on various math exprs that should/shouldn't succeed and/or get back original text
    [ ] milestone: initial type analysis as part of compiling a grammar
    [ ] milestone: initial error diagnostic accumulation as part of parse/unparse internal operation
    [x] get unparse() working end-to-end; test it
    [ ] DRYify the very similar code in parse and unparse templates
    [x] add math expression grammar as test fixture
    [x] add API function to parse a grammar and return AST (temporary)
    [x] add API function to parse a grammar and spit out source for a `parse()` function:
    [ ] add API function to parse a grammar and spit out source for an `unparse()` function
    [x] `i32`: get it working for natural numbers (ie no sign)
    [x] `i32`: support negative integers
    [x] `i32`: are exponents normally supported for int literals? What do other langs do? ANS: no exponents on int lits
    [ ] `i32`: if int is too large, we return `Fail`, but probably better to be some kind of error. What to do?
    [ ] `Module` and `Record` are basically the same - flech out any differences and/or merge concepts
      [ ] difference: module can have non-exported bindings, whereas all record properties are visible outside
    [ ] `Record`: rewrite in terms of `Selection`/`Sequence` etc
    [ ] `StringLiteral`: better word than 'uniform' for the "..." variant? (eg parallel, matching, constant, ordinary)
    [ ] `Sequence` comninator: revise code when we know if the 'type' of the seqence is 'string' or not
    [ ] review assert()s in template parse/unparse code - most should be static errors detectable from AST analysis
      [ ] sequences that produce multiple nodes
      [ ] record field values of NO_NODE
    [ ] theory: investigate memoisation for correctness
      [ ] when parsing, we only use `state.S` as the memo key. What about other state? Any example of incorrectness?
      [ ] do we need memoisation when unparsing? In which cases and why?
    [ ] way to add newline spacing between decls in emitted TS?
    [ ] only need `start` prop if binding value isn't a combinator factory call (eg string lits, simple delegation)
        [ ] `function isCombinator(astNode) {...}`
    [ ] doc resemblence of combinators to generic types that need 'instantiation' to make types
    [ ] support automatic insertion of Memo<...> around rhs of left-recursive rules (define subtasks...)
    [ ] add UMD build using webpack, as per how `multimethods` does it




TODO: clarify terminology:
    'Combinator' - function that takes functions and returns a function:
    'Parser Combinator' - function that takes parse functions and returns a parse function:
        - so `Selection` and `Sequence` are parser combinators
        - what about `Record`? it's sort of hybrid
    'Parser Factory' - function that returns a parser:
        - so `Identifier` and `StringLiteral`

    'AST' vs 'text':
        - 'ast', consisting of nodes, one node
        - 'text', consisting of spans, one span


TODO: list perf tips (and benchmark them):
    avoid allocations
    avoid iterators - prefer `for (;;)`
