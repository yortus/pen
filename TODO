Todo:
    [x] add math expression grammar as test fixture
    [x] add API function to parse a grammar and return AST (temporary)
    [x] add API function to parse a grammar and spit out source for a `parse()` function:
    [ ] add API function to parse a grammar and spit out source for an `unparse()` function
    [x] `i32`: get it working for natural numbers (ie no sign)
    [x] `i32`: support negative integers
    [x] `i32`: are exponents normally supported for int literals? What do other langs do? ANS: no exponents on int lits
    [ ] `i32`: if int is too large, we return `Fail`, but probably better to be some kind of error. What to do?
    [ ] `Record`: rewrite in terms of `Selection`/`Sequence` etc
    [ ] statically error on sequences that don't produce a single node (and remove assert()s from template code)
    [ ] way to add newline spacing between decls in emitted TS?
    [ ] only need `start` prop if binding value isn't a combinator factory call (eg string lits, simple delegation)
        [ ] `function isCombinator(astNode) {...}`
    [ ] doc resemblence of combinators to generic types that need 'instantiation' to make types
    [ ] support automatic insertion of LeftRec (define subtasks...)
    [ ] add UMD build using webpack, as per how `multimethods` does it




TODO: clarify terminology:
    'Combinator' - function that takes functions and returns a function:
    'Parser Combinator' - function that takes parse functions and returns a parse function:
        - so `Selection` and `Sequence` are parser combinators
        - what about `Record`? it's sort of hybrid
    'Parser Factory' - function that returns a parser:
        - so `Identifier` and `StringLiteral`

    'AST' vs 'text':
        - 'ast', consisting of nodes, one node
        - 'text', consisting of spans, one span


TODO: list perf tips (and benchmark them):
    avoid allocations
    avoid iterators - prefer `for (;;)`
